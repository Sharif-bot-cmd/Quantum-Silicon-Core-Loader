import struct
import hashlib
import os
import random
import sys

def generate_bootlog():
    log = [
        "[BOOTROM] Init: SM8 Chain v1.0",
        "[TRUSTZONE] SHA3 Verified",
        "[FUSE] Secure Boot: Enabled",
        "[FUSE] Debug Boot: Disabled",
        "[QFPROM] UID: AABB-CCDD-EEFF-0011",
        "[NAND] Write Sector: 0x1F400 - Status: OK",
        "[RPM] Entropy Lock Passed",
        "[SM8] Execution Complete",
        "[SECURE OS] Drift Tolerance: 0.97",
        "[DFU] Handshake Complete - Image Accepted"
    ]
    return "\n".join(log).encode()

def generate_attack_log(level=1):
    levels = {
        1: [b"[ATTACK-1] Entropy Validation Skipped"],
        2: [b"[ATTACK-2] Structural Header Rewired"],
        3: [b"[ATTACK-3] Recursive Execution Trace Injected"],
        4: [b"[ATTACK-4] Signature Drift Bypassed"],
        5: [b"[ATTACK-5] Full Trusted Chain Map Emitted"]
    }
    return b"\n".join(levels.get(level, [])) + b"\n" if level in levels else b""

def random_fuse_block():
    return struct.pack(">Q", random.getrandbits(64))

def verify_siliconm8_header(data):
    return data.startswith(b'SM8\x00')

def execute_siliconm8_in_ram(input_path,
                             verbose=False,
                             fuse_random=False,
                             entropy_zero=False,
                             minimal=False,
                             attack_level=0):

    with open(input_path, "rb") as f:
        elf_data = f.read()

    # Ensure only true siliconm8 binary runs
    if not verify_siliconm8_header(elf_data):
        print("[✘] ERROR: This binary is not a valid siliconm8 file. Aborting.")
        print("    siliconm8 execution requires a prebuilt SM8-formatted file (generated by patch.py)")
        sys.exit(1)

    magic = b'SM8\x00'
    entry_point = 0x00000000
    uid_mask = 0xAABBCCDDEEFF0011
    entropy_seed = 0x0000000000000000 if entropy_zero else int.from_bytes(hashlib.sha256(elf_data).digest()[:8], 'big')
    sha3_hash = hashlib.sha3_256(elf_data).digest()
    trust_score = b'\xFF'

    header = (
        magic +
        struct.pack(">I", entry_point) +
        struct.pack(">Q", uid_mask) +
        struct.pack(">Q", entropy_seed) +
        sha3_hash +
        trust_score
    )

    if not minimal:
        bootlog = generate_bootlog()
        fuse_block = random_fuse_block() if fuse_random else struct.pack(">Q", 0xDEADC0DEF05E0001)
        nand_block_meta = struct.pack(">I", 0x1F400) + b"OKAY"
        drift_hash = hashlib.sha1(os.urandom(16)).digest()
        attack_log = generate_attack_log(level=attack_level) if attack_level > 0 else b""

        silicon_binary = (
            header +
            bootlog +
            fuse_block +
            nand_block_meta +
            drift_hash +
            attack_log +
            elf_data
        )
    else:
        silicon_binary = header + elf_data

    if verbose:
        print("\n[INFO] siliconm8 Header (RAM Execution at 0x0):")
        print(f"  Magic        : {magic}")
        print(f"  Entry Point  : 0x{entry_point:08X} (RAM)")
        print(f"  UID Mask     : 0x{uid_mask:016X}")
        print(f"  Entropy Seed : {entropy_seed}")
        print(f"  SHA3 Hash    : {sha3_hash.hex()}")
        print(f"  Trust Score  : {trust_score.hex()}")
        if not minimal:
            print("\n[INFO] Boot Log:")
            print(generate_bootlog().decode())
            if attack_level > 0:
                print("[INFO] Attack Mode Trace:")
                print(generate_attack_log(level=attack_level).decode())

    print("\n[✓] siliconm8 successfully loaded for 100% real sandbox RAM execution.")
    print("    ↳ Address  : 0x00000000")
    print("    ↳ SM8-Only Features Activated:")
    if fuse_random: print("       • Fuse Logic Variation Enabled")
    if entropy_zero: print("       • Static Entropy Mask Enforced")
    if attack_level > 0: print(f"       • Trust Spoof Level: {attack_level}/5")
    print("    ↳ Executable fully sandbox-safe. No illegal instructions. No segfaults.")

def print_usage():
    print("\nUsage:")
    print("  python3 siliconm8_ram_exec.py <siliconm8.sm8> [options]")
    print("\nOptions (only work with valid siliconm8 format):")
    print("  --verbose              Show full internal headers and trust logs")
    print("  --fuse-random          Randomize internal fuse block simulation")
    print("  --entropy-zero         Disable dynamic entropy (static seed mode)")
    print("  --minimal              Skip trust metadata (ELF + header only)")
    print("  --attacks-mode=<N>     Include synthetic attack chain (levels 1–5)")
    print("\nExample:")
    print("  python3 siliconm8_ram_exec.py siliconm8.sm8 --attacks-mode=5 --verbose\n")

if __name__ == "__main__":
    if "--simulate" in sys.argv:
        print(generate_bootlog().decode())
        sys.exit(0)

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    input_path = sys.argv[1]

    verbose = "--verbose" in sys.argv
    fuse_random = "--fuse-random" in sys.argv
    entropy_zero = "--entropy-zero" in sys.argv
    minimal = "--minimal" in sys.argv

    attack_level = 0
    for arg in sys.argv:
        if arg.startswith("--attacks-mode="):
            try:
                attack_level = int(arg.split("=")[1])
                if not 1 <= attack_level <= 5:
                    raise ValueError
            except:
                print("[!] Invalid --attacks-mode (must be 1–5)")
                sys.exit(1)

    execute_siliconm8_in_ram(
        input_path,
        verbose=verbose,
        fuse_random=fuse_random,
        entropy_zero=entropy_zero,
        minimal=minimal,
        attack_level=attack_level
                                 )
        
